#########################################
# Generates a grid as a list structure
# with squares being placed randomly

# prob is the probability that a 1 shows up
# sq_num is the number of square in each row and column
#########################################

def generate_grid(prob,sq_num):
    grid = []
    
    # Your code here
    for rows in range(0,sq_num):
        grid.append(sq_num*[0])
        
    for list1 in range(0,sq_num):
        for element in range(0,sq_num):
            if (random.random() <= prob):
                grid[list1][element] = 1
    return grid

def append_treasure_to_grid(treasure1_x, treasure1_y, treasure2_x, treasure2_y, treasure3_x, treasure3_y, grid, grid_size, sq_num):
    row = int(treasure1_y/(grid_size/sq_num))
    col = int((treasure1_x)/(grid_size/sq_num))
    row2 = int(treasure2_y/(grid_size/sq_num))
    col2 = int((treasure2_x)/(grid_size/sq_num))
    row3 = int(treasure3_y/(grid_size/sq_num))
    col3 = int((treasure3_x)/(grid_size/sq_num))
    
    grid[row][col] = 2
    grid[row2][col2] = 2
    grid[row3][col3] = 2
    #print(grid)


        


#########################################
# Use the grid generated by generate_grid()
# and draw on the display surface

# grid is the list structure with 1 if a barrier will be plotted there, 0 otherwise
# sq_size is the length and width of each cell within the grid
# sq_num is the number of squares in each row and column
# surf is the name of the display surface to which we are plotting in pygame
#########################################

def draw_barrier(grid, sq_size, sq_num, surf,im):
    
    # Your code here
    for row in range(0,sq_num):
        for col in range(0,sq_num):
            if grid[row][col] == 1:
                                
                surf.blit(im, (sq_size*col, sq_size*row))

#########################################
# Given the player's current location as 
# the coordinate (x_player,y_player), 
# returns the cell row/column pair 
# corresponding to its location in the grid

# m is the length and width of the game window
# cell_num is the number of cells in each row and column
#########################################
def get_cell( m, cell_num, x_player, y_player):
    
    # Your code here
    sq_size = m/cell_num
    
    row = int( y_player/sq_size )
    col = int( x_player/sq_size )
    
    return (row, col)

#########################################
# Given knowledge of a cell number, a row,column combination
# produces a 4-tuple of the physical coordinates of each of the 
# four corners of the square

# m is the length and width of the game window
# cell_num is the number of cells in each row and column
# row is the row number in the grid
# col is the column number in the grid
#########################################

def corner_points(m, cell_num, row, col):
    
    # Your code here
    sq_size = m/cell_num
    
    top_left = (col*sq_size, row*sq_size)
    top_right = (col*sq_size + sq_size, row*sq_size)
    bottom_left = (col*sq_size, row*sq_size + sq_size)
    bottom_right = (col*sq_size + sq_size,row*sq_size + sq_size)
    
    return [top_left, top_right, bottom_left, bottom_right ]

def remove_treasure(treasure, x_pos, y_pos, GRID_SIZE, SQ_NUM):
    player_pos = ()
    player_pos = get_cell(GRID_SIZE, SQ_NUM, x_pos, y_pos)
    if player_pos == treasure:
        return False
    else:
        return True

def player_hit(enemy_x, enemy_y, player_x, player_y, grid_size, sq_num):
    hit = 0
    enemy_x, enemy_x2, enemy_y, enemy_y2 = get_dimensions(enemy_x, enemy_y, grid_size, sq_num)
    player_x, player_x2, player_y, player_y2 = get_dimensions(player_x, player_y, grid_size, sq_num)
    
    if enemy_x in range(int(player_x), int(player_x2)):
        #print("first x hit")
        hit += 1
    elif enemy_x2 in range(int(player_x), int(player_x2)):
        #print("second x hit")
        hit+=1
    
    if enemy_y in range(int(player_y), int(player_y2)):
        #print("first y hit")
        hit += 1
    elif enemy_y2 in range(int(player_y), int(player_y2)):
        #print("second y hit")
        hit += 1

    if hit >= 2:
        return True
    else:
        return False


def get_dimensions(x_pos, y_pos, grid_size, sq_num):
    length = grid_size/sq_num
    min_x_pos = (x_pos)
    max_x_pos = (x_pos + length)
    min_y_pos = (y_pos)
    max_y_pos = (y_pos + length)

    return min_x_pos, max_x_pos, min_y_pos, max_y_pos
    
    



def move(x_pos, y_pos, dist, grid, grid_size, sq_num):
    length = grid_size/sq_num        
    if event.key == pygame.K_LEFT:
        # Check to see if a left keystroke will result in movement. If the player will be off screen as a result of the 
        # key press, do not advance the x coordinate. If the player will be moving through a barrier, do not advance the
        # x coordinate. If the player will not move into an obstruction or off screen, advance the x coordinate (accordingly)
        # by a step of size dist.
        row = int(y_pos/length)
        col = int((x_pos-dist)/length)
        row2 = int((y_pos+length-1)/(length))
        
        if grid[row][col] == 1 or grid[row2][col] == 1:
            pass
        elif (x_pos - dist)<0:
            pass
        else:
            x_pos -= dist

    if event.key == pygame.K_RIGHT:
        row = int(y_pos/(length))
        col = int((x_pos+dist+length-1)/(length))
        row2 = int((y_pos+length-1)/(length))
        
        if(x_pos+dist) > (grid_size-(length)):
            pass
        elif grid[row][col] == 1 or grid[row2][col] == 1:
            pass
        else:
            x_pos += dist
        

    if event.key == pygame.K_UP:
        row = int((y_pos-dist)/(length))
        col = int((x_pos)/(length))
        col2 = int((x_pos+length-1)/(length))
        
        if grid[row][col] == 1 or grid[row][col2] == 1:
            pass
        elif(y_pos-dist) < 0:
            pass
        else:
            y_pos -= dist
        
        
    if event.key == pygame.K_DOWN:
        row = int((y_pos+dist+length-1)/(length))
        col = int((x_pos)/(length))
        col2 = int((x_pos+length-1)/(length))
        #print("down: col2: ",col2)
        #print('down: col: ',col)
        #print('down: row: ',row)
        if(y_pos+dist) > (grid_size-(length)):
            pass
        elif grid[row][col] == 1 or grid[row][col2] == 1:
            pass
        else:
            y_pos += dist
        
    return x_pos,y_pos,chng_score


def enemy_move(enemy_x, enemy_y, player_x, player_y, dist, grid, grid_size, sq_num):
    length = grid_size/sq_num
    y_difference = (enemy_y - player_y)
    
    x_difference = (enemy_x - player_x)
    
    stats = {
        "original_distance" : math.sqrt(((y_difference)*(y_difference)) + ((x_difference)*(x_difference))),
        "move_up_distance"  : math.sqrt(((y_difference+dist)*(y_difference+dist)) + ((x_difference)*(x_difference))),
        "move_down_distance": math.sqrt(((y_difference-dist)*(y_difference-dist)) + ((x_difference)*(x_difference))),
        "move_right_distance": math.sqrt(((y_difference)*(y_difference)) + ((x_difference+dist)*(x_difference+dist))),
        "move_left_distance": math.sqrt(((y_difference)*(y_difference)) + ((x_difference-dist)*(x_difference-dist))),
    }
    
    if (min(stats.items(), key=operator.itemgetter(1))[0]) == "move_up_distance":
        row = int((enemy_y+dist+length-1)/(length))
        col = int((enemy_x+length-1)/(length))
        col2 = int((enemy_x)/(length))
        if grid[row][col] == 1:
            pass
        elif grid[row][col2] == 1:
            pass
        elif(enemy_y+dist) > (grid_size-(length)):
            pass
        else:
            enemy_y += dist
    elif (min(stats.items(), key=operator.itemgetter(1))[0]) == "move_down_distance":
        row = int((enemy_y-dist)/(length))
        col = int((enemy_x)/(length))
        col2 = int((enemy_x+length-1)/(length))
        
        if grid[row][col] == 1:
            pass
        elif grid[row][col2] == 1:
            pass
        elif(enemy_y-dist) < 0:
            pass
        else:
            enemy_y -= dist
    elif (min(stats.items(), key=operator.itemgetter(1))[0]) == "move_right_distance":
        row = int(enemy_y/(length))
        col = int((enemy_x+dist+length-1)/(length))
        row2 = int((enemy_y+length-1)/(length))
        
        if grid[row][col] == 1:
            pass
        elif grid[row2][col] == 1:
            pass
        elif(enemy_x+dist) > (grid_size-(length)):
            pass
        else:
            enemy_x += dist
    elif (min(stats.items(), key=operator.itemgetter(1))[0]) == "move_left_distance":
        row = int(enemy_y/(length))
        col = int((enemy_x-dist)/(length))
        row2 = int((enemy_y+length-1)/(length))
        
        if grid[row][col] == 1:
            pass
        elif grid[row2][col] == 1:
            pass
        elif (enemy_x - dist)<0:
            pass
        else:
            enemy_x -= dist
       
    
    
    return enemy_x, enemy_y


# Import statements
import pygame, sys
from pygame.locals import *
import random
import math
import operator

# Define some constants
x_pos = 0 # Player initial x position
y_pos = 0 # Player initial y position
GRID_SIZE = 600 # Pixels x Pixels of console size
SQ_NUM = 10 # Number of squares in grid
SQ_SIZE = int(GRID_SIZE/SQ_NUM) # Dimension of each square
t1 = True
t2 = True
t3 = True
chng_score = False
player_lives = 3
immunity = False
count = 0
high_score = 0




# Boiler plate startup stuff
pygame.init() 
DISPLAYSURF = pygame.display.set_mode( (GRID_SIZE,GRID_SIZE) )
FPS = 60 
fpsClock = pygame.time.Clock()
pygame.display.set_caption('Indiana Jones PacMan')


# Generate the grid to be used in the game loop
SQ_NUM = 10
grid = generate_grid(0.15, SQ_NUM)


# Define initial enemy locations - set them randomly in the game frame, but avoid cells with barriers
# Run through all the cells and update empty_cells list with row,col combinations that have no barrier
# Then, randomly choose a starting cell for each enemy and place the top-left corner of the enemy 
# sprite in this cell
empty_cells = []
for row in range(0,SQ_NUM):
    for col in range(0,SQ_NUM):
        if grid[row][col] == 0:
            empty_cells.append((row,col))
enemy1_start_cell = random.choice(empty_cells)            
enemy2_start_cell = random.choice(empty_cells)  
treasure1_start_cell = random.choice(empty_cells)
treasure2_start_cell = random.choice(empty_cells)
treasure3_start_cell = random.choice(empty_cells)
treasure4_start_cell = random.choice(empty_cells)
enemy1_x = enemy1_start_cell[0]*SQ_SIZE
enemy1_y = enemy1_start_cell[0]*SQ_SIZE
enemy2_x = enemy2_start_cell[0]*SQ_SIZE
enemy2_y = enemy2_start_cell[0]*SQ_SIZE
treasure1_x = treasure1_start_cell[0]*SQ_SIZE
treasure1_y = treasure1_start_cell[0]*SQ_SIZE
treasure2_x = treasure2_start_cell[0]*SQ_SIZE
treasure2_y = treasure2_start_cell[0]*SQ_SIZE
treasure3_x = treasure3_start_cell[0]*SQ_SIZE
treasure3_y = treasure3_start_cell[0]*SQ_SIZE

t1_grid = get_cell(GRID_SIZE, SQ_NUM, treasure1_x, treasure1_y)
t2_grid = get_cell(GRID_SIZE, SQ_NUM, treasure2_x, treasure2_y)
t3_grid = get_cell(GRID_SIZE, SQ_NUM, treasure3_x, treasure3_y)

check_1 = True
check_2 = True
check_3 = True

player_im = pygame.image.load("pow.jpg")
player_im = pygame.transform.scale(player_im, (SQ_SIZE, SQ_SIZE))
enemy_im = pygame.image.load("cv.jpg")
enemy_im = pygame.transform.scale(enemy_im, (SQ_SIZE, SQ_SIZE))
enemy_im2 = pygame.image.load("trump.jpg")
enemy_im2 = pygame.transform.scale(enemy_im2, (SQ_SIZE, SQ_SIZE))
barrier_im = pygame.image.load("brick.jpg")
barrier_im = pygame.transform.scale(barrier_im, (SQ_SIZE, SQ_SIZE))
t1_im = pygame.image.load("money.jpg")
t1_im = pygame.transform.scale(t1_im, (SQ_SIZE, SQ_SIZE))
t2_im = pygame.image.load("money.jpg")
t2_im = pygame.transform.scale(t2_im, (SQ_SIZE, SQ_SIZE))
t3_im = pygame.image.load("money.jpg")
t3_im = pygame.transform.scale(t3_im, (SQ_SIZE, SQ_SIZE))

score = 0


# Main game loop
while True:
    for event in pygame.event.get():

        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

        if player_lives <= 0:
            print("YOU ARE DEAD")
            draw_barrier(grid, 60, SQ_NUM, DISPLAYSURF, barrier_im)

            append_treasure_to_grid(treasure1_x, treasure1_y, treasure2_x, treasure2_y,
                                    treasure3_x, treasure3_y, grid, GRID_SIZE, SQ_NUM
                                    )
            if score > high_score:
                high_score = score
            player_lives = 3
            score = 0
            immunity = True
            x_pos = 0
            y_pos = 0
            count = 0
            check_1 = True
            check_2 = True
            check_3 = True
            #enemy1_x = random.randint(range(0,SQ_NUM))
            #enemy1_y = random.randint(range(0,SQ_NUM))
            #enemy2_x = random.randint(range(0,SQ_NUM))
            #enemy2_y = random.randint(range(0,SQ_NUM))

        elif check_1 ==False and check_2 ==False and check_3 == False:
            print("You got the treasure!!!")
            if high_score < score:
                high_score = score
            draw_barrier(grid, 60, SQ_NUM, DISPLAYSURF, barrier_im)

            append_treasure_to_grid(treasure1_x, treasure1_y, treasure2_x, treasure2_y,
                                    treasure3_x, treasure3_y, grid, GRID_SIZE, SQ_NUM
                                    )
            immunity = True
            x_pos = 0
            y_pos = 0
            count = 0
            check_1 = True
            check_2 = True
            check_3 = True
            #enemy1_x = random.randint(range(0,SQ_NUM))
            #enemy1_y = random.randint(range(0,SQ_NUM))
            #enemy2_x = random.randint(range(0,SQ_NUM))
            #enemy2_y = random.randint(range(0,SQ_NUM))

        # Fill the surface background with the RGB color
        DISPLAYSURF.fill( (204,255,255) )
        font = pygame.font.Font('freesansbold.ttf', 32) # sets the font and size of the text
        text = 'score: '+str(score) + ' lives: '+str(player_lives) + ' HS: '+str(high_score)
        text = font.render(text, True, (50,50,50), (100,100,100)) #This renders the text. Change things and see what it does
        textRect = text.get_rect() # Creates a rectangular object for the text. Boilerplate... change nothing
        textRect.center = (300, 15) # Places the center of the text at (100,200) on the screen
        # Draw the barriers based on values in the grid list
        # created before the game loop
        draw_barrier(grid, 60, SQ_NUM, DISPLAYSURF, barrier_im)

        append_treasure_to_grid(treasure1_x, treasure1_y, treasure2_x, treasure2_y,
                                treasure3_x, treasure3_y, grid, GRID_SIZE, SQ_NUM
                                )
        
        # Check to see if a button has been pressed.
        # If an arrow key has been pressed, call the move() function and determine new x and y coordinates.
        if event.type == pygame.KEYDOWN:
            
            x_pos,y_pos,chng_score = move(x_pos, y_pos, 10, grid, GRID_SIZE, SQ_NUM)
    
        #Get new coordinates the enemies will move to. If enemy hits player, dont move til immunity off
        if not immunity:
            enemy1_x, enemy1_y = enemy_move(enemy1_x, enemy1_y, x_pos, y_pos, 1, grid, GRID_SIZE, SQ_NUM)
            enemy2_x, enemy2_y = enemy_move(enemy2_x, enemy2_y, x_pos, y_pos, 1, grid, GRID_SIZE, SQ_NUM)
        else:
            count += 1
             
        # Draw player and both enemy images to the screen using the blit() function
        DISPLAYSURF.blit(player_im, (x_pos,y_pos))
        DISPLAYSURF.blit(enemy_im, (enemy1_x, enemy1_y))
        DISPLAYSURF.blit(enemy_im2, (enemy2_x, enemy2_y))

        # Check if either enemy gets the player, if they do, player is immune for 10 events
        if not immunity:
            if player_hit(enemy1_x, enemy1_y, x_pos, y_pos, GRID_SIZE, SQ_NUM):
                player_lives -= 1
                immunity = True
                count = 0
            if player_hit(enemy2_x, enemy2_y, x_pos, y_pos, GRID_SIZE, SQ_NUM):
                player_lives -= 1
                immunity = True
                count = 0
        else:
            print("You are immune")
        # Just the counter for how long player is immune after getting hit
        if count > 30:
            count = 0
            immunity = False


        
        t1_local = t1_grid
        t2_local = t2_grid
        t3_local = t3_grid
        
        if check_1:
            if remove_treasure(t1_local, x_pos, y_pos, GRID_SIZE, SQ_NUM):
                DISPLAYSURF.blit(t1_im, (treasure1_x, treasure1_y))
            else:
                check_1 = False
                score+= 100
        if check_2:
            if remove_treasure(t2_local, x_pos, y_pos, GRID_SIZE, SQ_NUM):
                DISPLAYSURF.blit(t2_im, (treasure2_x, treasure2_y))
            else:
                check_2 = False
                score+= 100
        if check_3:
            if remove_treasure(t3_local, x_pos, y_pos, GRID_SIZE, SQ_NUM):
                DISPLAYSURF.blit(t3_im, (treasure3_x, treasure3_y))
            else:
                check_3 = False
                score+= 100
  
        DISPLAYSURF.blit(text,textRect)
        
    # Advance the game counter
    pygame.display.update()
    fpsClock.tick(FPS)